// This is a skeleton starter React component generated by Plasmic.
// This file is owned by you, feel free to edit as you see fit.
import * as React from "react";
import {
  PlasmicAddItem,
  DefaultAddItemProps
} from "./plasmic/isv/PlasmicAddItem";
import { HTMLElementRefOf } from "@plasmicapp/react-web";
import { fetchContentfulEntry } from "./contentful";
import { addToCart, getProductVariantPrice } from "../lib/cart";
import { addProductState, AppPage, OptionType, state } from "../lib/state-management";
import { useSnapshot } from "valtio";

export interface AddItemProps extends DefaultAddItemProps {
}

function AddItem_(props: AddItemProps, ref: HTMLElementRefOf<"div">) {
  const { ...rest } = props;
  const refFooter = React.createRef<HTMLDivElement>();

  const productStateSnap = useSnapshot(addProductState);
  useSnapshot(state).appPage;

  const product = fetchContentfulEntry(productStateSnap.productId);
  if (productStateSnap.product === undefined && product) {
    addProductState.product = product;
    addProductState.optionsType = Object.fromEntries(product.fields.options.map((option: any) => 
      [option.sys.id as string, option.fields.maximum !== undefined ? OptionType.multi : OptionType.single]
    )) as Record<string, OptionType>;
    addProductState.sumOfOptionValuesQuantity = Object.fromEntries(product.fields.options.map((option: any) => 
      [option.sys.id as string, 0]
    )) as Record<string, number>;
  }

  React.useEffect(() => {
    window.scrollTo({top: 0})
  }, [])
  const totalPrice = productStateSnap.product
    ? "R$ " + (getProductVariantPrice(productStateSnap)).toFixed(2)
    : 0;

  const isReady = (Object.entries(productStateSnap.sumOfOptionValuesQuantity).every(([optionId, quantity]) => 
    (productStateSnap.product?.fields.options.find((option: any) => option.sys.id === optionId).fields.maximum ?? 1)
    === quantity
  ));


  return <PlasmicAddItem 
    root={{ ref }} 
    {...rest} 
    back={{
      wrap: (node) => <div onClick={() => state.appPage = AppPage.home}>{node}</div>
    }}
    selectedOptionValues={{
      children: (
        Object.entries(productStateSnap.optionValues)
          .sort(([_a, {optionId: optionIdA }], [_b, {optionId: optionIdB}]) => 
            product?.fields.options.findIndex((option: any) => option.sys.id === optionIdA) - 
            product?.fields.options.findIndex((option: any) => option.sys.id === optionIdB)
          )
          .map(([_, { optionId, valueId, quantity }]) => 
            <div>
              {productStateSnap.optionsType[optionId] === OptionType.multi ? `${quantity}x ` : ''}
              {product?.fields.options
                .find((option: any) => option.sys.id === optionId)
                ?.fields.values.find((currOptionValue: any) => currOptionValue.sys.id === valueId)
                ?.fields.label
              }
            </div>
          )
      )
    }}
    button={{
      isDisabled: !isReady,
      onClick: () => {
        if (productStateSnap.productId) {
          addToCart();
        }
        state.appPage = AppPage.checkout;
      }
    }}
    scrollSpace={{
      height: (document.getElementById("footer")?.getClientRects()[0].height ?? 200) + 50
    }}
    footer={{ref: refFooter}}
    total={totalPrice}
  />;
}

const AddItem = React.forwardRef(AddItem_);
export default AddItem;