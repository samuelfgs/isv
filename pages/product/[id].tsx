// This is a skeleton starter React page generated by Plasmic.
// This file is owned by you, feel free to edit as you see fit.
import * as React from "react";
import { useRouter } from "next/router";
import { PlasmicAddItem } from "../../components/plasmic/isv/PlasmicAddItem";
import { useSnapshot } from "valtio";
import { addProductState, OptionType } from "../../lib/state-management";
import { fetchContentfulEntry } from "../../components/contentful";
import { addToCart, getProductVariantPrice } from "../../lib/cart";
import { GetStaticPropsContext, NextPageContext } from "next";
import * as Contentful from "contentful";
import { extractPlasmicQueryData } from "@plasmicapp/prepass";
import { SWRConfig } from "swr";

function AddItem({ id, queryCache }: { id: string, queryCache: Record<string, any> }) {
    const refFooter = React.createRef<HTMLDivElement>();
    const productStateSnap = useSnapshot(addProductState);
    const router = useRouter();
    
    const product = fetchContentfulEntry(productStateSnap.productId);
    const [scrollSpaceHeight, setScrollSpaceHeight] = React.useState(0);

    React.useEffect(() => {
      setScrollSpaceHeight(
        (document?.getElementById("footer")?.getClientRects()[0].height ?? 200) + 50
      );
    }, []);
  
    if (productStateSnap.product === undefined && product) {
      addProductState.product = product;
      addProductState.optionsType = Object.fromEntries(product.fields.options.map((option: any) => 
        [option.sys.id as string, option.fields.maximum !== undefined ? OptionType.multi : OptionType.single]
      )) as Record<string, OptionType>;
      addProductState.sumOfOptionValuesQuantity = Object.fromEntries(product.fields.options.map((option: any) => 
        [option.sys.id as string, 0]
      )) as Record<string, number>;
    }
  
    React.useEffect(() => {
      window.scrollTo({top: 0})
    }, [])
    const totalPrice = productStateSnap.product
      ? "R$ " + (getProductVariantPrice(productStateSnap)).toFixed(2)
      : 0;
  
    const isReady = (Object.entries(productStateSnap.sumOfOptionValuesQuantity).every(([optionId, quantity]) => 
      (productStateSnap.product?.fields.options.find((option: any) => option.sys.id === optionId).fields.maximum ?? 1)
      === quantity
    ));
  
    return <SWRConfig
      value={{
        fallback: queryCache
      }}
    >
      <PlasmicAddItem
        entryId={id}
        back={{
          wrap: (node) => <div onClick={() => router.push("/")}>{node}</div>
        }}
        header={{
          hideHeader: true
        }}
        selectedOptionValues={{
          children: (
            Object.entries(productStateSnap.optionValues)
              .sort(([_a, {optionId: optionIdA }], [_b, {optionId: optionIdB}]) => 
                product?.fields.options.findIndex((option: any) => option.sys.id === optionIdA) - 
                product?.fields.options.findIndex((option: any) => option.sys.id === optionIdB)
              )
              .map(([_, { optionId, valueId, quantity }]) => 
                <div>
                  {productStateSnap.optionsType[optionId] === OptionType.multi ? `${quantity}x ` : ''}
                  {product?.fields.options
                    .find((option: any) => option.sys.id === optionId)
                    ?.fields.values.find((currOptionValue: any) => currOptionValue.sys.id === valueId)
                    ?.fields.label
                  }
                </div>
              )
          )
        }}
        button={{
          isDisabled: !isReady,
          onClick: () => {
            if (productStateSnap.productId) {
              addToCart();
            }
            router.push("/checkout");
          }
        }}
        scrollSpace={{
          height: scrollSpaceHeight
        }}
        footer={{ref: refFooter}}
        total={totalPrice}
      />
    </SWRConfig>;
}

export async function getStaticProps(context: GetStaticPropsContext) {
  if (typeof context.params?.id !== "string") {
    return {
      props: {
        id: context.params?.id
      }
    }
  }
  // Cache the necessary data fetched for the page.
  const queryCache = await extractPlasmicQueryData(
    <AddItem id={context.params?.id} queryCache={{}} />
  );
  console.log("dale", queryCache);
  return {
    props: {
      id: context.params?.id,
      queryCache
    },
  }
}

export async function getStaticPaths() {
  const creds = {
    accessToken: "ZhMf0iObSvHFPx861zNK4VNL6kOrURuEQh5R24_QdvE" as const,
    environment: "master" as const,
    space: "1qzqoknl91s3" as const,
  };
  const client = Contentful.createClient({
    space: creds.space,
    accessToken: creds.accessToken,
  });
  const response = await client.getEntries({
    content_type: "eventMenuItem"
  });
  return {
    paths: response.items.map((item: any) => ({ params: { id: item.sys.id }})),
    fallback: false, // can also be true or 'blocking'
  }
}

export default AddItem;
