// This is a skeleton starter React page generated by Plasmic.
// This file is owned by you, feel free to edit as you see fit.
import * as React from "react";
import { useRouter } from "next/router";
import { PlasmicAddItem } from "../../components/plasmic/isv/PlasmicAddItem";
import { useSnapshot } from "valtio";
import { addProductState, OptionType } from "../../lib/state-management";
import { ContentfulFetcher, fetchContentfulEntry } from "../../components/contentful";
import { addToCart, getProductVariantPrice } from "../../lib/cart";
import { GetStaticPropsContext, NextPageContext } from "next";
import * as Contentful from "contentful";
import { extractPlasmicQueryData } from "@plasmicapp/prepass";
import { SWRConfig } from "swr";
import PlasmicGlobalContextsProvider from "../../components/plasmic/isv/PlasmicGlobalContextsProvider";

function AddItem({ id, queryCache, prepass }: { id: string, queryCache: Record<string, any>, prepass?: boolean }) {
  const refFooter = React.createRef<HTMLDivElement>();
  const productStateSnap = useSnapshot(addProductState);
  const router = useRouter();
  
  const product = fetchContentfulEntry(productStateSnap.productId);
  const [scrollSpaceHeight, setScrollSpaceHeight] = React.useState(0);

  React.useEffect(() => {
    setScrollSpaceHeight(
      (document?.getElementById("footer")?.getClientRects()[0].height ?? 200) + 50
    );
  }, []);
  
  if (productStateSnap.product === undefined && product) {
    addProductState.product = product;
    addProductState.optionsType = Object.fromEntries(product.fields.options.map((option: any) => 
      [option.sys.id as string, option.fields.maximum !== undefined ? OptionType.multi : OptionType.single]
    )) as Record<string, OptionType>;
    addProductState.sumOfOptionValuesQuantity = Object.fromEntries(product.fields.options.map((option: any) => 
      [option.sys.id as string, 0]
    )) as Record<string, number>;
  }
  
  React.useEffect(() => {
    window.scrollTo({top: 0})
  }, [])
  const totalPrice = productStateSnap.product
    ? "R$ " + (getProductVariantPrice(productStateSnap)).toFixed(2)
    : 0;

  const isReady = (Object.entries(productStateSnap.sumOfOptionValuesQuantity).every(([optionId, quantity]) => 
    (productStateSnap.product?.fields.options.find((option: any) => option.sys.id === optionId).fields.maximum ?? 1)
    === quantity
  ));
  
  const wrapper = (children: React.ReactNode) => (
    prepass 
      ? children
      : (
        <SWRConfig
          value={{
            fallback: queryCache
          }}
        >
          {children}
        </SWRConfig>
      )
  )
  return <>
    {wrapper(
      <PlasmicAddItem
        entryId={id}
        back={{
          wrap: (node) => <div onClick={() => router.push("/")}>{node}</div>
        }}
        header={{
          hideHeader: true
        }}
        selectedOptionValues={{
          children: (
            Object.entries(productStateSnap.optionValues)
              .sort(([_a, {optionId: optionIdA }], [_b, {optionId: optionIdB}]) => 
                product?.fields.options.findIndex((option: any) => option.sys.id === optionIdA) - 
                product?.fields.options.findIndex((option: any) => option.sys.id === optionIdB)
              )
              .map(([_, { optionId, valueId, quantity }]) => 
                <div>
                  {productStateSnap.optionsType[optionId] === OptionType.multi ? `${quantity}x ` : ''}
                  {product?.fields.options
                    .find((option: any) => option.sys.id === optionId)
                    ?.fields.values.find((currOptionValue: any) => currOptionValue.sys.id === valueId)
                    ?.fields.label
                  }
                </div>
              )
          )
        }}
        button={{
          isDisabled: !isReady,
          onClick: () => {
            if (productStateSnap.productId) {
              addToCart();
            }
            router.push("/checkout");
          }
        }}
        scrollSpace={{
          height: scrollSpaceHeight
        }}
        footer={{ref: refFooter}}
        total={totalPrice}
      />
    )}
  </>
}

export async function getStaticProps(context: GetStaticPropsContext) {
  if (typeof context.params?.id !== "string") {
    return {
      props: {
        id: context.params?.id
      }
    }
  }
  // Cache the necessary data fetched for the page.
  const queryCache = await extractPlasmicQueryData(
    <PlasmicGlobalContextsProvider>
      <AddItem id={context.params?.id} queryCache={{}} prepass={true} />
    </PlasmicGlobalContextsProvider>
  );
  return {
    props: {
      id: context.params?.id,
      queryCache,
    },
  }
}

export async function getStaticPaths() {
  const creds = {
    accessToken: "ZhMf0iObSvHFPx861zNK4VNL6kOrURuEQh5R24_QdvE" as const,
    environment: "master" as const,
    space: "1qzqoknl91s3" as const,
  };
  const client = Contentful.createClient({
    space: creds.space,
    accessToken: creds.accessToken,
  });
  const response = await client.getEntries({
    content_type: "eventMenuItem"
  });
  return {
    paths: response.items.map((item: any) => ({ params: { id: item.sys.id }})),
    fallback: false, // can also be true or 'blocking'
  }
}

export default AddItem;
